name: Redux 快速入门教程
description: >-
  前端状态日益复杂，随着进入2019年，大前端时代到来，前端愈来愈注重处理逻辑，而不只是专注 UI 层面的改进，而以 React
  为代表的前端框架的出现，大大简化了我们编写 UI 界面的复杂度，但是逻辑层就交给了开发者，虽然 React 提供了
  State，this.props.parentMethod() 等 API 帮助你编写逻辑，也有诸如 Lifting-State-Up
  等开发约定，帮助减少程序的不可控性，但是所有的这些都只能在小型应用上适用，当你的前端应用有多达 10
  个以上的页面时，如何让应用状态可控，如何让协作开发高效就是一个亟待解决的问题，而 Redux 的出现正是为了解决这些问题而生的！Redux 提出的
  Single-Source-of-Truth，单向数据流，Pure Reducers
  大大简化了前端逻辑，使得我们可以以高效的、便于协作的方式编写任意复杂的前端应用。本篇教程致力于用简短的文字讲透 Redux，让你快速了解 Redux
  概念的同时，还能完成一个待办事项小应用。
topics:
  - Redux
categories:
  - ''
  - React
  - ''
id: 4ada16faecf470bf265f52276bdc9170
created: '2019-11-28T12:13:49.486Z'
updated: 2019-11-30T08:14:11.580Z
steps:
  - name: 在我们阅读教程之前
    commit: f706830
    diff:
      - file: .gitignore
      - file: README.md
        display: false
      - file: package.json
        display: false
      - file: public/favicon.ico
        display: false
      - file: public/index.html
        display: false
      - file: public/logo192.png
        display: false
      - file: public/logo512.png
        display: false
      - file: public/manifest.json
        display: false
      - file: public/robots.txt
        display: false
      - file: src/components/AddTodo.js
        display: false
      - file: src/components/App.js
        display: false
      - file: src/components/Footer.js
        display: false
      - file: src/components/Link.js
        display: false
      - file: src/components/Todo.js
        display: false
      - file: src/components/TodoList.js
        display: false
      - file: src/index.js
        display: false
      - file: tuture.yml
      - file: yarn.lock
        display: false
    explain:
      pre: >+
        Redux 官方文档对 Redux 的定义是 -- 一个可预测的 JavaScript 应用状态管理容器。


        这就意味着，Redux 是无法单独运作的，也就是说它需要与一个具体的 View 层的前端框架相结合才能发挥出它的威力，这里的 View
        层包括但不限于 React，Vue 或者 Angular 等，而我们这篇教程将使用 React 作为绑定视图层，因为 Redux 最初诞生于
        React 社区，以解决 React 的逻辑层问题出发而设计和开发的一个库，所以当对比 React 在处理逻辑方面的缺陷以及 Redux
        的改进来学习 Redux 能帮助我们理解它的源起，以及它将走向什么样的远方。


        ### 前提条件


        本篇教程是关于 Redux 的快速入门教程，并致力于讲解与 React 绑定时的使用，而了解和掌握 Redux 对于一个 React
        开发者来说属于较为进阶的内容，所以我们假设在阅读本篇教程之前，你需要拥有以下的知识储备：


        - 对 ES6
        的函数、类、`const`、对象结构、函数默认参数等概念有良好的了解，当然如果你了解过函数式编程，对纯函数，不变性等有过了解就更好了。

        - 对 React 有良好的了解，对 `state`、`this.setState`，`props` 和
        `lifting-stating-up` 等概念有一定了解，当然如果有独立开发过至少有 5 个页面的 React 应用的经验就更好了。

        - 了解 node 和 npm，有过相关的安装依赖的经验即可。


        对于以上的前提要求中的相关概念，受限于篇幅，本篇教程不会深入去讲解，但是如果你想要补习一下关于 JavaScript 和 React
        的知识，这里推荐你一些学习资料：


        - [MDN 的重新介绍 JavaScript
        ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript) 

        - 图雀社区的 [React 快速入门教程](https://tuture.co/2019/11/18/07acf61/)：讲解 React
        的基础

        - 图雀社区的 [使用 React 实现一个井字棋游戏（一）](https://tuture.co/2019/11/13/175b717/)和
        [使用 React 实现一个井字棋游戏（二）](https://tuture.co/2019/11/13/3697248/)：在讲解 React
        基础的同时，对 React 的 `lifting-state-up` ，函数式组件，不变性都做了具体的讲解。


        ### 你将学到什么


        在本篇教程中，我们将首先给出了一个[使用 React
        实现的待办事项小应用](https://codesandbox.io/s/redux-quickstart-tutorial-4968k)，它将是我们学习
        Redux
        的起点，所以我们希望你一开始能够理解我们给出的代码模板如何运作的，以及它实现的效果是怎么样的，当你熟悉了这份初始代码，并了解了它实现效果之后，你就可以关闭它，然后开始我们教程的学习啦！


        我们将基于这个纯 React 写成的模板，在讲解 React 在处理状态时存在的问题，并基于这个问题提出使用 Redux
        实现将带来的优势，并使用 Redux 来重构这份初始模板。


        最后你将了解如何将一个 React 应用一步一步的重构成一个 Redux 应用，并了解如何使用 Redux 完成一个简单的待办事项小应用。


        ### 代码和最终效果


        本教程所实现的源代码都托管在 Github 上：


        - 纯 React
        源码：[源码地址](https://github.com/pftom/redux-quickstart-tutorial/tree/initial-code)。

        - 使用 Redux
        重构后的源码：[源码地址](https://github.com/pftom/redux-quickstart-tutorial)。


        你可以通过 CodeSandbox 查看代码最终的效果：


        - 纯 React
        效果：[最终效果地址](https://codesandbox.io/s/redux-quickstart-tutorial-4968k)。

        - 使用 Redux
        重构后的效果：[最后效果地址](https://codesandbox.io/s/redux-quickstart-tutorial-4968k)。


        当然图雀社区的每一步骤的 [Diff 代码](https://tuture.co/FAQ/)都会给出对应的 Github
        地址，你可以在跟随者教程学习并动手敲代码的同时，查看自己的代码是否与本步骤的参考代码想吻合，便于你快速纠错。


        ### Help！帮帮忙！


        如果你遇到了问题，可以通过文章末尾的评论区向作者进行提问，你提出的问题将会以 Issue 的方式发布者图雀社区的 [Github
        仓库](https://github.com/tuture-dev/comments/issues)里。


        如果你的问题没有得到答复，那么我们推荐你加入我们的 [Gitter
        频道](https://gitter.im/tuture-dev/tuture)，到频道里面进行提问，这样你可以得到快速的答复。



  - name: 开始 Redux 之旅
    commit: 0526fa5
    diff:
      - file: package.json
        display: true
        explain:
          pre: >-
            ### 准备初始代码


            将初始 React 代码模板 Clone 到本地：


            ```Bash

            git clone
            https://github.com/pftom/redux-quickstart-tutorial/tree/initial-code

            ```


            安装项目依赖：


            ```Bash

            cd redux-quickstart-tutorial

            npm install

            npm start

            ```


            接着 React 开发服务器会打开浏览器，如果你看到下面的效果，并且可以进行操作，那么代表代码准备完成：


            ![![](tuture-assets/image-51c89987a1725452.png)](tuture-assets/image-c272df98562701e3.png)


            ### 探索初始代码


            我们完成的这个待办事项小应用比较简单，我们希望展示一个 todo 列表，当一个  todo 被点击时，它将被加上删除线表示此 todo
            已经完成，我们还加上了一个输入框，使得用户可以增加新的 todo。在底部，我们展示了三个按钮，可以切换展示 todo 的类型。


            我们的整份 React 代码组件设计如下，首先是组件，然后是组件所拥有的属性：


            - `TodoList` 用来展示 todo 列表：
              -  `todos: Array` 是一个 todo 数组，它其中的每个元素的样子类似 `{ id, text, completed }`。
              - `toggleTodo(id: number)` 是当一个 todo 被点击时会调用的回调函数。 
            - `Todo` 是单一 todo 组件：
              - `text: string` 是这个 todo 将显示的内容。
              - `completed: boolean` 用来表示是否完成，如果完成，那么样式上就会给这个元素划上删除线。
              - `onClick()` 是当这个 todo 被点击时将调用的回调函数。
            - `Link` 是一个展示过滤的按钮：
              - `active: boolean` 代表此时被选中，那么此按钮将不能被点击
              - `onClick()` 表示这个 link 被点击时将调用的回调函数。
              - `children: ReactComponent` 展示子组件
            - `Footer` 用于展示三个过滤按钮：
              - `filter: string` 代表此时的被选中的过滤器字符串，它是 `[SHOW_ALL, SHOW_COMPLETED, SHOW_ACTIVE]` 其中之一。
              - `setVisibilityFilter()` 代表 Link 被点击时将设置对应被点击的 `filter` 的回调函数。
            - `App` 是 React 根组件，最终组合其他组件并使用 ReactDOM 对其进行编译渲染，我们在它的 `state`
            上定义了上面的几个组件会用到的属性，同时定义了其他组件会用到的方法，还有
            `nextTodoId`，`VisibilityFilters`，`getVisibleTodos` 等一些辅助函数。


            ### 准备 Redux 环境


            我们知道 Redux 可以与多种视图层开发框架如 React，Vue  和 Angular 等搭配使用，而 Redux
            只是一个状态管理容器，所以为了在 React 中使用 Redux，我们还需要安装一下对应的依赖。


            ```Bash

            npm install redux

            npm install react-redux

            ```


            最后我们的 `package.json` 文件的内容应该发生了下面的变化：
          post: >-
            ### 小结


            我们首先给出一张 Redux 概览图，然后详细解释了概览图的三个部分。


            在你对 Redux 有个初步的了解的基础上，我们引导你将初始的 React 模板代码 Clone
            到了本地，并且安装了相关依赖，开启了开发服务器，这样你可以看到初始的用 React 实现的效果。


            接着我们通过解释每一个组件的形式来整体介绍了我们现有的这份 React 初始模板的含义，以及它的组成部分和对应的作用。


            最后我们安装了在 React 中使用 Redux 的必要依赖。


            做得好！现在一切已经准备就绪，相信你已经迫不及待的想要编写一点 Redux 相关的代码了，别担心，在下一节中，我们将引出 Redux
            Store 的详细概念，并且通过代码讲解它将替换 React  的哪个部分。
      - file: yarn.lock
        display: false
    explain:
      pre: >-
        不管外界把  Redux 吹得如何天花乱坠，实际上它可以用一张图来概括，这张图也有利于帮助你思考前端它的本质是什么：


        ![](tuture-assets/image.png)


        我们先来详解一下这张图，并且在教程之后的内容中，你会多次看到这张图以不同的形式出现，我们希望学完本篇教程之后，每当你想起 Redux
        时，脑海里就是这张图：


        ### View


        首先我们来看 View ，在前端开发中，我们称这个为视图层，就是展示给最终用户的效果，在本篇教程的学习中，我们的 View 就是 React。


        ### Store


        随着前端应用要完成的工作越来越丰富，我们对前端也提出了要保持 “状态” 的要求，在 React 中，这个 “状态” 将保存在
        `this.state`。在 Redux 中，这个状态将保存在 Store。


        这个 Store 从抽象意义上来说可以看做一个前端的 “数据库”，它保存着前端的状态（state），并且分发这些状态给 View，使得 View
        根据这些状态渲染不同的内容。


        注意到，Redux 是一个可预测的 JavaScript 应用状态管理容器，这个状态容器就是这里的 Store。


        ### Reducers


        我们日常生活中看到的网页，它不是一成不变的，而是会响应用户的 “动作”，无论是页面跳转也好，还是登陆注册也好。


        这里的 “动作” 可能是一次性的或者临时的，那么我们需要短暂的记录这一动作，而 Reducers 就是用来更新 Store 来记录这些 
        “动作” 带来的修改的一个个函数。


        当我们对三个核心概念有一个粗略的认知之后，我们就可以开始 Redux 的学习了。
  - name: '理解 Store:数据的唯一真相来源'
    commit: daa3220
    diff:
      - file: src/index.js
        display: true
        explain:
          pre: >-
            ### 打湿你的双手


            了解了 Redux Store 之于 React 的作用之后，我们马上在 React 应用 Redux ，看看神奇的 Store
            是如何介入并产生如此大的变化的。


            在   `src/index.js`  中做出如下修改：
          post: >-
            可以看到，上面的代码做了下面几下工作：


            - 我们首先进行了导包操作，从 `redux` 中导出了 `createStore`，从 `react-redux` 导出了
            `Provider`，从 `src/components/App.js` 中导出了 `VisibilityFilters` 。

            - 接着我们定义了一个 `initialState` 对象，这将作为我们之后创建 Store 的初始状态数据，也是我们之前提到的那颗
            JavaScript 对象树的初始值。

            - 然后我们定义了一个 `rootReducer` 函数，它是一个箭头函数，接收 `state` 和 `action` 然后返回
            `state` ，这个函数目前还没有完成任何工作，但是它是创建 Store 所必须的参数之一，我们将在之后的 Reducers
            中详细讲解它。



            ::: warning

            Reducers 替换成锚点

            :::


            - 再接着，我们调用之前导出的 Redux API： `createStore` 函数，传入定义的 `rootReducer` 和
            `initialState` ，生成了我们本节的主角：store！

            - 最后我们在 `App` 组件的最外层使用 `Provider` 包裹，并接收我们上一步创建的 `store`
            作为参数，这确保之后我们可以在子组件中访问到 store 中的状态。`Provider` 是 `react-redux` 提供的
            API，是 Redux 在 React 使用的绑定库，它搭建起 Redux 和 React 交流的桥梁。
      - file: src/components/App.js
        display: true
        explain:
          pre: >-
            现在我们已经创建了 Store，并使用了 React 与 Redux 的绑定库 `react-redux` 提供的 `Provider`
            组件将 Store 与 React 组件组合在了一起。


            现在我们马上来看一下整合 Store 与 React 之后的效果。


            打开 `src/components/App.js` ，对文件内容作出如下修改：
          post: >+
            可以看到，上面的代码做了这几项工作：


            - 首先我们从 `react-redux` 绑定库里面导出了 `connect` 函数。

            - 然后在文件底部，我们定义了一个 `mapStateToProps` 箭头函数，它接收 `state` 和 `props` ，这个
            `state`  就是我们那颗 Store 里面保存的 JavaScript 对象状态树，目前就是我们在上一个文件中定义的 
            `initialState` 内容；这个 `props` 就是我们熟悉的原 React 组件的 `props`。
            `mapStateToProps` 函数就是可以同时操作组件的原 `props` 和 Store 的状态，然后合并成最终的组件
            props，（当然这里我们并没有使用原组件 props 内容）并通过 `connect` 函数传递给 `App` 组件。

            - `connect` 函数接收 `mapStateProps` 函数，获取 `mapStateProps`
            返回的最终组合后的状态，然后将其注入到 `App` 组件中，返回一个新的组件，然后交给 `export default` 导出。

            - 经过上面的工作，我们在 `App` 组件中就可以取到通过 `mapStateToProps` 返回的 `{ todos,
            filter }` 内容了，我们通过对象结构，从 `this.props` 拿到 `todos` 和 `filter` 属性。

            - 最后我们删除不再需要的 `constructor` 中的 `this.state` 内容。



            ::: info

            **注意**


            这里之所以我们能在 `App` 组件中通过 `mapStateToProps` 拿到 Store 中保存的 JavaScript
            对象状态树，是因为我们在之前通过 `Provider` 包裹了 `App` 组件，并将 `store` 作为属性传递给了
            `Provider`。

            :::



            ### 再现 Redux 环形图


            ![![](tuture-assets/image-f650ac40893ad6fd.png)](tuture-assets/image-452906c4c6e9dce3.png)


            现在再来看一看我们在第一步骤中提到的图例，我们现在处于这个流程的第一步，即将 Store 里面的状态传递到 View 中，具体我们是通过
            React 的 Redux 绑定库 `react-redux` 中的 `connect` 实现的。

    explain:
      pre: >-
        我们前面提到了 Store 在 Redux 中的作用是用来保存状态的，相当于我们在前端建立了一个简单的
        ”数据库“，在目前的富状态前端应用中，如果每一次状态的修改，比如我点击一个按钮，都需要与后端通信，那么整个网站应用的体验将糟糕透顶。



        ::: info

        根据不完全统计：”一个网站能留住一名用户的时间只有8S，如果你在8S内不能吸引住用户，或者出现了网站出现了问题，那么你将彻底的丢失这名用户！”

        :::


        所以为了适应用户的访问需求，聪明的前端拓荒者们开始将后端的 “数据库” 理念引进前端中，为前端也上了一个
        “数据库”，这样大多数的前端状态可以直接在前端搞定，完全不需要后端的介入。


        ### 罪恶的 React State


        在 React 中，我们将状态存在每个组件的 `this.state` 中，每个组件的 `state`
        为组件所私有，我们想要在一个组件中操作另外一个组件就需要相当繁琐的实现。


        我们将用下面这张图来讲解一下这些繁琐之处：


        ![](tuture-assets/image-fc337c2c5936372a.png)


        即组件B想要操作组件C，那么它首先不需要调用父组件A传给它的 `handleClick` 方法，然后通过这个方法修改父组件A的
        `state`，进而通过 React 的自动重新渲染机制，触发组件 C 的变化。


        现在组件 B 和组件 C 是处于平级的，你可能还感觉不到这种跨组件改变有什么问题，让我们再来看一张图：


        ![](tuture-assets/image-a16996b94b001828.png)


        我们看到上面这张图，组件 B 和组件 C 相差了很多级，图中的 n 可能为10，也可能更多，这个时候你在想在组件 B 中修改组件
        C，那就要把这个 `handleClick` 方法一层一层的往下传，当要修改的时候，再进行调用，这已经显得相当繁琐了。


        如果组件 C离组件A还有很深的层级，情况就更复杂了：


        ![](tuture-assets/image-b60dccc2228876a7.png)


        这时候，不仅要把 `handleClick` 方法通过很深的层级传给组件 B，当组件 B 调用 `hanldeClick` 方法时，修改组件 A
        的 `state`，再反过来传递给组件 C时，组件 A 到组件 C
        之间的所有组件都会触发重新渲染，这带来了巨额的渲染开销，当我们的应用越来越复杂，这种开销显然是承受不起的。


        ### 解救者：Store


        React 诞生的初衷就是为了更好，更高效率的编写用户界面 ，它不应该也不需要来承担状态管理的职责。


        于是备受折磨的前端拓荒者们构想出了伟大的 Store。我们完全不需要让每个组件单独保持状态，直接抽离所有组件的状态，类比 React
        组件树，构造一个中心化的状态树，这颗状态树与 React 组件树一一对应，相当于对 React 组件树进行了状态化建模：


        ![](tuture-assets/image-2caca42ea90c2b26.png)


        可以看到，我们将组件的 state 去掉，取而代之的是一颗状态树，它是一个普通的 JavaScript
        对象，通过对象的嵌套来类比组件的嵌套组合，这颗由 JavaScript 对象建模的状态树就是 Redux 中的 Store。


        当我们将组件的状态抽离出去之后，我们在使用组件 B 操作组件 C 就变得相当简单且高效。


        ![](tuture-assets/image-5c903471bbce55b3.png)


        我们在组件 B 中发起一个更新状态 C 的动作，此动作对应的更新函数更新 Store 状态树，之后将更新后的状态 C 传递给组件 C，触发组件
        C 的重新渲染。


        可以看到，当我们引入这种机制之后，组件 B 与组件 C 之间的交互就单独发生了，不会影响 React 组件树中的其他组件，也不需要传递很深层级的
        `handleClick` 函数了，再也不需要把更新后的 `state` 一层一层的传给组件 C，还要耗费性能的影响所有中间的组件了。


        有了 Redux Store 之后，所有 React 应用中的状态修改都是对这颗 JavaScript 对象树的修改，所有状态的获取都是从这颗
        JavaScript 对象树获取，这颗 JavaScript 对象代表的状态树成了整个应用的 “数据的唯一真相来源”。
      post: >
        保存改变的内容，如果你的 React 开发服务器打开着，那么你应该可以在浏览器中看到如下内容：


        ![](tuture-assets/image-9711dbe24f236c42.png)


        恭喜你！你已经成功编写了 Redux 的 Store，完成将 Redux 整合进 React 工作的 1/3。 通过在 React 中接入
        Store，你成功的将 Redux 和 React 之间的数据打通，并删除了 `this.state` ，使用 Store 的状态来取代
        `this.state`。


        但是！当你此时点击 `Add Todo` 按钮，你的浏览器应该会显示出红色的错误，因为我们已经删除了 `this.state` 的内容，所以在
        `onSubmit` 方法中读取 `this.state.todos` 就会报错。别担心，我们将在下一节中： `Action`
        中讲解如何解决这些错误。



        ::: warning

        Action 替换成锚点

        :::
github: 'https://github.com/pftom/redux-quickstart-tutorial'
